# Web View Mode Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a dynamic "web" view that renders Content::Document directly via QPainter in a continuous, reflow-able layout — no page boundaries, no PDF generation.

**Architecture:** The Layout::Engine gets a new `layoutContinuous()` method that reuses all block layout code but skips page assignment. A new `WebViewRenderer` translates the box tree into QPainter calls. A new `WebViewItem` QGraphicsItem hosts the continuous layout in DocumentView's scene.

**Tech Stack:** Qt6 (QGraphicsView, QPainter, QRawFont, QGlyphRun), existing HarfBuzz/Knuth-Plass layout engine.

**Design doc:** `docs/plans/2026-02-21-web-view-design.md`

---

### Task 1: Add `ContinuousLayoutResult` and `layoutContinuous()` to Layout::Engine

**Files:**
- Modify: `src/layout/layoutengine.h:248` (after `LayoutResult` struct)
- Modify: `src/layout/layoutengine.h:261` (Engine class public section)
- Modify: `src/layout/layoutengine.cpp:35` (after `layout()` method)

**Step 1: Add `ContinuousLayoutResult` struct to `layoutengine.h`**

Insert after the `LayoutResult` struct (after line 253):

```cpp
struct ContinuousLayoutResult {
    QList<PageElement> elements;       // each with absolute y position set
    qreal totalHeight = 0;
    qreal contentWidth = 0;
    QList<SourceMapEntry> sourceMap;   // pageNumber always 0, absolute rects
    QList<CodeBlockRegion> codeBlockRegions;
};
```

**Step 2: Add `layoutContinuous()` declaration to `Engine` class**

Insert after the `layout()` declaration (after line 261):

```cpp
    ContinuousLayoutResult layoutContinuous(const Content::Document &doc, qreal availWidth);
```

**Step 3: Implement `layoutContinuous()` in `layoutengine.cpp`**

Insert after the `layout()` method (after line 138). This method reuses all the
block layout methods but skips `assignToPages()` — elements are stacked vertically
with simple y accumulation:

```cpp
ContinuousLayoutResult Engine::layoutContinuous(const Content::Document &doc,
                                                  qreal availWidth)
{
    ContinuousLayoutResult result;
    result.contentWidth = availWidth;

    // Layout all blocks into page elements (identical to layout())
    QList<PageElement> elements;

    for (const auto &block : doc.blocks) {
        std::visit([&](const auto &b) {
            using T = std::decay_t<decltype(b)>;
            if constexpr (std::is_same_v<T, Content::Paragraph>) {
                if (b.inlines.size() == 1
                    && std::holds_alternative<Content::InlineImage>(b.inlines.first())) {
                    const auto &img = std::get<Content::InlineImage>(b.inlines.first());
                    if (!img.resolvedImageData.isEmpty())
                        elements.append(layoutImage(img, availWidth));
                } else {
                    elements.append(layoutParagraph(b, availWidth));
                }
            } else if constexpr (std::is_same_v<T, Content::Heading>) {
                elements.append(layoutHeading(b, availWidth));
            } else if constexpr (std::is_same_v<T, Content::CodeBlock>) {
                elements.append(layoutCodeBlock(b, availWidth));
            } else if constexpr (std::is_same_v<T, Content::BlockQuote>) {
                auto bqElements = layoutBlockQuote(b, availWidth);
                elements.append(bqElements);
            } else if constexpr (std::is_same_v<T, Content::List>) {
                auto listElements = layoutList(b, availWidth);
                elements.append(listElements);
            } else if constexpr (std::is_same_v<T, Content::Table>) {
                elements.append(layoutTable(b, availWidth));
            } else if constexpr (std::is_same_v<T, Content::HorizontalRule>) {
                elements.append(layoutHorizontalRule(b, availWidth));
            } else if constexpr (std::is_same_v<T, Content::FootnoteSection>) {
                elements.append(layoutFootnoteSection(b, availWidth));
            }
        }, block);
    }

    // Simple vertical stacking — no page breaks, no splitting
    qreal y = 0;
    for (auto &element : elements) {
        qreal spaceBefore = 0;
        qreal height = 0;
        qreal spaceAfter = 0;

        std::visit([&](auto &e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, BlockBox>) {
                spaceBefore = e.spaceBefore;
                height = e.height;
                spaceAfter = e.spaceAfter;
            } else if constexpr (std::is_same_v<T, TableBox>) {
                height = e.height;
            } else if constexpr (std::is_same_v<T, FootnoteSectionBox>) {
                spaceBefore = 20.0;
                height = e.height;
            }
        }, element);

        y += spaceBefore;

        // Set absolute y position
        std::visit([&](auto &e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, BlockBox>) {
                e.y = y;
            } else if constexpr (std::is_same_v<T, TableBox>) {
                e.y = y;
            } else if constexpr (std::is_same_v<T, FootnoteSectionBox>) {
                e.y = y;
            }
        }, element);

        result.elements.append(element);

        y += height + spaceAfter;
    }

    result.totalHeight = y;

    // Build source map (absolute positions, pageNumber = 0)
    for (const auto &element : result.elements) {
        std::visit([&](const auto &e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, BlockBox>) {
                if (e.source.startLine > 0) {
                    SourceMapEntry entry;
                    entry.pageNumber = 0;
                    entry.rect = QRectF(e.x, e.y, e.width, e.height);
                    entry.startLine = e.source.startLine;
                    entry.endLine = e.source.endLine;
                    result.sourceMap.append(entry);

                    if (e.type == BlockBox::CodeBlockType) {
                        CodeBlockRegion region;
                        region.pageNumber = 0;
                        region.rect = QRectF(
                            e.x - e.padding, e.y - e.padding,
                            e.width + e.padding * 2, e.height + e.padding * 2);
                        region.startLine = e.source.startLine;
                        region.endLine = e.source.endLine;
                        result.codeBlockRegions.append(region);
                    }
                }
            } else if constexpr (std::is_same_v<T, TableBox>) {
                if (e.source.startLine > 0) {
                    SourceMapEntry entry;
                    entry.pageNumber = 0;
                    entry.rect = QRectF(e.x, e.y, e.width, e.height);
                    entry.startLine = e.source.startLine;
                    entry.endLine = e.source.endLine;
                    result.sourceMap.append(entry);
                }
            }
        }, element);
    }

    return result;
}
```

**Step 4: Build and verify**

Run: `cmake --build build --target PrettyReaderCore -j$(nproc)`
Expected: Compiles clean. No runtime test needed yet — just a new method.

**Step 5: Commit**

```
feat(layout): add layoutContinuous() for web view mode

Reuses all block layout methods (paragraph, heading, table, code block,
etc.) but stacks elements vertically without page assignment or
splitting. This is the layout engine half of the web view feature.
```

---

### Task 2: Create `WebViewRenderer` — QPainter rendering of box tree

This is the largest task. `WebViewRenderer` is a stateless helper that translates
each box type into QPainter calls. It mirrors `PdfGenerator`'s render methods
but targets QPainter instead of PDF content streams.

**Key coordinate difference from PdfGenerator:** PDF uses bottom-up Y (origin at
bottom-left). QPainter uses top-down Y (origin at top-left). So where PdfGenerator
does `blockY = originY - box.y`, WebViewRenderer just uses `box.y` directly since
both the layout engine and QPainter use top-down Y.

**Files:**
- Create: `src/canvas/webviewrenderer.h`
- Create: `src/canvas/webviewrenderer.cpp`
- Modify: `src/CMakeLists.txt:22-25` (add new files to PrettyReaderCore)

**Step 1: Create `webviewrenderer.h`**

```cpp
/*
 * webviewrenderer.h — QPainter-based rendering of Layout box tree
 *
 * Translates BlockBox/TableBox/FootnoteSectionBox into QPainter calls.
 * Used by WebViewItem for the web view mode.
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

#ifndef PRETTYREADER_WEBVIEWRENDERER_H
#define PRETTYREADER_WEBVIEWRENDERER_H

#include "layoutengine.h"

#include <QHash>
#include <QRawFont>

class FontManager;
class QPainter;

struct LinkHitRect {
    QRectF rect;
    QString href;
};

class WebViewRenderer
{
public:
    explicit WebViewRenderer(FontManager *fontManager);

    void renderBlockBox(QPainter *painter, const Layout::BlockBox &box);
    void renderTableBox(QPainter *painter, const Layout::TableBox &box);
    void renderFootnoteSectionBox(QPainter *painter, const Layout::FootnoteSectionBox &box);

    const QList<LinkHitRect> &linkHitRects() const { return m_linkHitRects; }
    void clearLinkHitRects() { m_linkHitRects.clear(); }

private:
    void renderLineBox(QPainter *painter, const Layout::LineBox &line,
                       qreal originX, qreal originY, qreal availWidth);
    void renderGlyphBox(QPainter *painter, const Layout::GlyphBox &gbox,
                        qreal x, qreal baselineY);
    void renderHersheyGlyphBox(QPainter *painter, const Layout::GlyphBox &gbox,
                                qreal x, qreal baselineY);
    void renderGlyphDecorations(QPainter *painter, const Layout::GlyphBox &gbox,
                                 qreal x, qreal baselineY, qreal endX);
    void renderCheckbox(QPainter *painter, const Layout::GlyphBox &gbox,
                        qreal x, qreal baselineY);
    void renderImageBlock(QPainter *painter, const Layout::BlockBox &box);

    QRawFont rawFontFor(FontFace *face, qreal sizePoints);

    FontManager *m_fontManager;
    QHash<QPair<FontFace *, int>, QRawFont> m_rawFontCache; // key: (face, size*100)
    QList<LinkHitRect> m_linkHitRects;
};

#endif // PRETTYREADER_WEBVIEWRENDERER_H
```

**Step 2: Create `webviewrenderer.cpp`**

```cpp
/*
 * webviewrenderer.cpp — QPainter rendering of Layout box tree
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

#include "webviewrenderer.h"
#include "fontmanager.h"
#include "hersheyfont.h"

#include <QGlyphRun>
#include <QPainter>
#include <QPen>
#include <QRawFont>

WebViewRenderer::WebViewRenderer(FontManager *fontManager)
    : m_fontManager(fontManager)
{
}

QRawFont WebViewRenderer::rawFontFor(FontFace *face, qreal sizePoints)
{
    int sizeKey = qRound(sizePoints * 100);
    auto key = qMakePair(face, sizeKey);
    auto it = m_rawFontCache.find(key);
    if (it != m_rawFontCache.end())
        return it.value();

    QByteArray data = m_fontManager->rawFontData(face);
    QRawFont rf(data, sizePoints);
    m_rawFontCache.insert(key, rf);
    return rf;
}

// --- Block rendering ---

void WebViewRenderer::renderBlockBox(QPainter *painter, const Layout::BlockBox &box)
{
    // Background
    if (box.background.isValid()) {
        painter->save();
        painter->setPen(Qt::NoPen);
        painter->setBrush(box.background);
        QRectF bgRect(box.x - box.padding, box.y - box.padding,
                       box.width + box.padding * 2, box.height + box.padding * 2);
        painter->drawRect(bgRect);

        // Border
        if (box.borderWidth > 0 && box.borderColor.isValid()) {
            painter->setPen(QPen(box.borderColor, box.borderWidth));
            painter->setBrush(Qt::NoBrush);
            painter->drawRect(bgRect);
        }
        painter->restore();
    }

    // Image block
    if (box.type == Layout::BlockBox::ImageBlock) {
        renderImageBlock(painter, box);
        return;
    }

    // Horizontal rule
    if (box.type == Layout::BlockBox::HRuleBlock) {
        painter->save();
        painter->setPen(QPen(QColor(204, 204, 204), 0.5));
        qreal ruleY = box.y + box.height / 2;
        painter->drawLine(QPointF(0, ruleY), QPointF(box.width, ruleY));
        painter->restore();
        return;
    }

    // Blockquote left border
    if (box.hasBlockQuoteBorder && box.blockQuoteLevel > 0) {
        painter->save();
        painter->setPen(QPen(QColor(204, 204, 204), 2.0));
        qreal borderX = box.blockQuoteIndent - 8.0;
        qreal borderTop = box.y - box.spaceBefore;
        qreal borderBottom = box.y + box.height + box.spaceAfter;
        painter->drawLine(QPointF(borderX, borderTop), QPointF(borderX, borderBottom));
        painter->restore();
    }

    // Lines
    qreal lineY = 0;
    for (int li = 0; li < box.lines.size(); ++li) {
        qreal lineX = box.x;
        qreal lineAvailWidth = box.width;
        if (li == 0 && box.firstLineIndent != 0) {
            lineX += box.firstLineIndent;
            lineAvailWidth -= box.firstLineIndent;
        }
        renderLineBox(painter, box.lines[li], lineX, box.y + lineY, lineAvailWidth);
        lineY += box.lines[li].height;
    }
}

// --- Line rendering ---

void WebViewRenderer::renderLineBox(QPainter *painter, const Layout::LineBox &line,
                                     qreal originX, qreal originY, qreal availWidth)
{
    qreal baselineY = originY + line.baseline;

    // Justification
    bool doJustify = false;
    qreal extraPerGap = 0;
    qreal extraPerChar = 0;

    if (line.alignment == Qt::AlignJustify && !line.isLastLine
        && line.glyphs.size() > 1 && line.width < availWidth) {
        if (line.justify.wordGapCount > 0) {
            doJustify = true;
            extraPerGap = line.justify.extraWordSpacing;
            extraPerChar = line.justify.extraLetterSpacing;
        } else {
            int gapCount = 0;
            for (int i = 1; i < line.glyphs.size(); ++i) {
                if (line.glyphs[i].startsAfterSoftHyphen)
                    continue;
                if (line.glyphs[i].style.background.isValid()
                    && line.glyphs[i - 1].style.background.isValid()
                    && line.glyphs[i].style.background == line.glyphs[i - 1].style.background)
                    continue;
                if (line.glyphs[i - 1].isListMarker)
                    continue;
                gapCount++;
            }
            if (gapCount > 0) {
                qreal extraSpace = availWidth - line.width;
                qreal epg = extraSpace / gapCount;
                if (epg <= 20.0) { // reasonable max gap
                    doJustify = true;
                    extraPerGap = epg;
                }
            }
        }
    }

    qreal x;

    if (doJustify) {
        x = originX;
        for (int i = 0; i < line.glyphs.size(); ++i) {
            renderGlyphBox(painter, line.glyphs[i], x, baselineY);
            x += line.glyphs[i].width;
            if (i < line.glyphs.size() - 1)
                x += extraPerChar * line.glyphs[i].glyphs.size();
            if (i < line.glyphs.size() - 1) {
                bool skipGap = line.glyphs[i + 1].startsAfterSoftHyphen;
                if (!skipGap && line.glyphs[i + 1].attachedToPrevious)
                    skipGap = true;
                if (!skipGap && line.glyphs[i + 1].style.background.isValid()
                    && line.glyphs[i].style.background.isValid()
                    && line.glyphs[i + 1].style.background == line.glyphs[i].style.background)
                    skipGap = true;
                if (!skipGap && line.glyphs[i].isListMarker)
                    skipGap = true;
                if (!skipGap)
                    x += extraPerGap;
            }
        }
    } else {
        qreal xOffset = 0;
        if (line.alignment == Qt::AlignCenter)
            xOffset = (availWidth - line.width) / 2;
        else if (line.alignment == Qt::AlignRight)
            xOffset = availWidth - line.width;

        x = originX + xOffset;
        for (const auto &gbox : line.glyphs) {
            renderGlyphBox(painter, gbox, x, baselineY);
            x += gbox.width;
        }
    }

    // Trailing soft-hyphen
    if (line.showTrailingHyphen && !line.glyphs.isEmpty()) {
        const auto &lastGbox = line.glyphs.last();
        if (lastGbox.font && !lastGbox.font->isHershey) {
            QRawFont rf = rawFontFor(lastGbox.font, lastGbox.fontSize);
            if (rf.isValid()) {
                quint32 hyphenGid = 0;
                if (lastGbox.font->ftFace)
                    hyphenGid = FT_Get_Char_Index(lastGbox.font->ftFace, '-');
                if (hyphenGid > 0) {
                    QGlyphRun gr;
                    gr.setRawFont(rf);
                    gr.setGlyphIndexes({hyphenGid});
                    gr.setPositions({QPointF(0, 0)});
                    painter->save();
                    painter->setPen(lastGbox.style.foreground);
                    painter->drawGlyphRun(QPointF(x, baselineY), gr);
                    painter->restore();
                }
            }
        } else if (lastGbox.font && lastGbox.font->isHershey && lastGbox.font->hersheyFont) {
            // Hershey hyphen: draw the '-' glyph strokes
            HersheyFont *hFont = lastGbox.font->hersheyFont;
            const HersheyGlyph *hGlyph = hFont->glyph(U'-');
            if (hGlyph) {
                qreal scale = lastGbox.fontSize / hFont->unitsPerEm();
                painter->save();
                painter->setPen(QPen(lastGbox.style.foreground,
                                     0.02 * lastGbox.fontSize * (lastGbox.font->hersheyBold ? 1.8 : 1.0),
                                     Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
                QTransform t;
                if (lastGbox.font->hersheyItalic)
                    t = QTransform(scale, 0, -scale * 0.2126, scale, x, baselineY);
                else
                    t = QTransform(scale, 0, 0, scale, x, baselineY);
                painter->setTransform(t, true);
                for (const auto &stroke : hGlyph->strokes) {
                    if (stroke.size() < 2) continue;
                    QPolygonF poly;
                    for (const auto &pt : stroke)
                        poly << QPointF(pt.x() - hGlyph->leftBound, -pt.y());
                    painter->drawPolyline(poly);
                }
                painter->restore();
            }
        }
    }
}

// --- Glyph rendering (TTF via QRawFont + QGlyphRun) ---

void WebViewRenderer::renderGlyphBox(QPainter *painter, const Layout::GlyphBox &gbox,
                                      qreal x, qreal baselineY)
{
    // Dispatch Hershey fonts to their own renderer
    if (gbox.font && gbox.font->isHershey) {
        renderHersheyGlyphBox(painter, gbox, x, baselineY);
        return;
    }

    // Checkbox
    if (gbox.checkboxState != Layout::GlyphBox::NoCheckbox) {
        renderCheckbox(painter, gbox, x, baselineY);
        return;
    }

    if (gbox.glyphs.isEmpty() || !gbox.font)
        return;

    // Inline background
    if (gbox.style.background.isValid()) {
        painter->save();
        painter->setPen(Qt::NoPen);
        painter->setBrush(gbox.style.background);
        painter->drawRect(QRectF(x - 1, baselineY - gbox.ascent - 1,
                                  gbox.width + 2, gbox.ascent + gbox.descent + 2));
        painter->restore();
    }

    // Build QGlyphRun from shaped glyph data
    QRawFont rf = rawFontFor(gbox.font, gbox.fontSize);
    if (!rf.isValid())
        return;

    QVector<quint32> glyphIds;
    QVector<QPointF> positions;
    glyphIds.reserve(gbox.glyphs.size());
    positions.reserve(gbox.glyphs.size());

    qreal curX = 0;
    for (const auto &g : gbox.glyphs) {
        glyphIds.append(g.glyphId);
        qreal gx = curX + g.xOffset;
        qreal gy = -g.yOffset; // QPainter Y is top-down, glyph offsets are bottom-up
        if (gbox.style.superscript)
            gy -= gbox.fontSize * 0.35;
        else if (gbox.style.subscript)
            gy += gbox.fontSize * 0.15;
        positions.append(QPointF(gx, gy));
        curX += g.xAdvance;
    }

    QGlyphRun glyphRun;
    glyphRun.setRawFont(rf);
    glyphRun.setGlyphIndexes(glyphIds);
    glyphRun.setPositions(positions);

    painter->save();
    painter->setPen(gbox.style.foreground);
    painter->drawGlyphRun(QPointF(x, baselineY), glyphRun);
    painter->restore();

    renderGlyphDecorations(painter, gbox, x, baselineY, x + gbox.width);
}

// --- Hershey glyph rendering (stroked polylines) ---

void WebViewRenderer::renderHersheyGlyphBox(QPainter *painter, const Layout::GlyphBox &gbox,
                                              qreal x, qreal baselineY)
{
    if (gbox.glyphs.isEmpty() || !gbox.font || !gbox.font->hersheyFont)
        return;

    HersheyFont *hFont = gbox.font->hersheyFont;
    qreal fontSize = gbox.fontSize;
    qreal scale = fontSize / hFont->unitsPerEm();

    // Inline background
    if (gbox.style.background.isValid()) {
        painter->save();
        painter->setPen(Qt::NoPen);
        painter->setBrush(gbox.style.background);
        painter->drawRect(QRectF(x - 1, baselineY - gbox.ascent - 1,
                                  gbox.width + 2, gbox.ascent + gbox.descent + 2));
        painter->restore();
    }

    qreal strokeWidth = 0.02 * fontSize;
    if (gbox.font->hersheyBold)
        strokeWidth *= 1.8;

    qreal curX = x;
    for (const auto &g : gbox.glyphs) {
        const HersheyGlyph *hGlyph = hFont->glyph(static_cast<char32_t>(g.glyphId));
        if (!hGlyph) {
            curX += g.xAdvance;
            continue;
        }

        qreal gx = curX + g.xOffset;
        qreal gy = baselineY - g.yOffset;
        if (gbox.style.superscript)
            gy -= fontSize * 0.35;
        else if (gbox.style.subscript)
            gy += fontSize * 0.15;

        painter->save();
        painter->setPen(QPen(gbox.style.foreground, strokeWidth,
                              Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
        painter->setBrush(Qt::NoBrush);

        QTransform t;
        if (gbox.font->hersheyItalic)
            t = QTransform(scale, 0, -scale * 0.2126, scale, gx, gy);
        else
            t = QTransform(scale, 0, 0, scale, gx, gy);
        painter->setTransform(t, true);

        for (const auto &stroke : hGlyph->strokes) {
            if (stroke.size() < 2) continue;
            QPolygonF poly;
            for (const auto &pt : stroke)
                poly << QPointF(pt.x() - hGlyph->leftBound, -pt.y());
            painter->drawPolyline(poly);
        }

        painter->restore();
        curX += g.xAdvance;
    }

    renderGlyphDecorations(painter, gbox, x, baselineY, curX);
}

// --- Decorations (underline, strikethrough, links) ---

void WebViewRenderer::renderGlyphDecorations(QPainter *painter, const Layout::GlyphBox &gbox,
                                               qreal x, qreal baselineY, qreal endX)
{
    if (gbox.style.underline) {
        painter->save();
        painter->setPen(QPen(gbox.style.foreground, 0.5));
        qreal uy = baselineY + gbox.descent * 0.3;
        painter->drawLine(QPointF(x, uy), QPointF(endX, uy));
        painter->restore();
    }

    if (gbox.style.strikethrough) {
        painter->save();
        painter->setPen(QPen(gbox.style.foreground, 0.5));
        qreal sy = baselineY - gbox.ascent * 0.3;
        painter->drawLine(QPointF(x, sy), QPointF(endX, sy));
        painter->restore();
    }

    if (!gbox.style.linkHref.isEmpty()) {
        m_linkHitRects.append({QRectF(x, baselineY - gbox.ascent,
                                       endX - x, gbox.ascent + gbox.descent),
                                gbox.style.linkHref});
    }
}

// --- Checkbox rendering ---

void WebViewRenderer::renderCheckbox(QPainter *painter, const Layout::GlyphBox &gbox,
                                      qreal x, qreal baselineY)
{
    qreal size = gbox.fontSize * 0.7;
    qreal r = size * 0.12;
    qreal lw = size * 0.07;
    qreal cx = x + 1.0;
    qreal cy = baselineY - size * 0.75;

    QRectF boxRect(cx, cy, size, size);
    QColor strokeColor = gbox.style.foreground.isValid() ? gbox.style.foreground : QColor(0x33, 0x33, 0x33);

    painter->save();
    if (gbox.checkboxState == Layout::GlyphBox::Checked) {
        painter->setPen(QPen(strokeColor, lw));
        painter->setBrush(QColor(235, 242, 255));
        painter->drawRoundedRect(boxRect, r, r);

        // Checkmark
        QPen checkPen(strokeColor, lw * 1.5, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);
        painter->setPen(checkPen);
        painter->setBrush(Qt::NoBrush);
        QPolygonF check;
        check << QPointF(cx + size * 0.20, cy + size * 0.50)
              << QPointF(cx + size * 0.42, cy + size * 0.75)
              << QPointF(cx + size * 0.82, cy + size * 0.22);
        painter->drawPolyline(check);
    } else {
        painter->setPen(QPen(strokeColor, lw));
        painter->setBrush(Qt::NoBrush);
        painter->drawRoundedRect(boxRect, r, r);
    }
    painter->restore();
}

// --- Image rendering ---

void WebViewRenderer::renderImageBlock(QPainter *painter, const Layout::BlockBox &box)
{
    if (box.image.isNull())
        return;

    QRectF imgRect(box.x, box.y, box.imageWidth, box.imageHeight);
    painter->drawImage(imgRect, box.image);
}
```

**Step 3: Add files to `src/CMakeLists.txt`**

Insert after `canvas/rendercache.h` (after line 25):

```cmake
    canvas/webviewrenderer.cpp
    canvas/webviewrenderer.h
```

**Step 4: Build and verify**

Run: `cmake --build build --target PrettyReaderCore -j$(nproc)`
Expected: Compiles clean.

**Step 5: Commit**

```
feat(canvas): add WebViewRenderer for QPainter-based box tree rendering

Translates Layout::BlockBox, TableBox, and FootnoteSectionBox into
QPainter calls. Uses QRawFont + QGlyphRun for TTF glyph rendering
and stroked polylines for Hershey fonts. Mirrors PdfGenerator's
rendering operations but targets QPainter.
```

---

### Task 3: Create `WebViewItem` — QGraphicsItem for continuous layout

**Files:**
- Create: `src/canvas/webviewitem.h`
- Create: `src/canvas/webviewitem.cpp`
- Modify: `src/CMakeLists.txt` (add new files)

**Step 1: Create `webviewitem.h`**

```cpp
/*
 * webviewitem.h — QGraphicsItem for continuous web view rendering
 *
 * Hosts a ContinuousLayoutResult and paints it using WebViewRenderer.
 * Only elements overlapping the exposed rect are painted (binary search).
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

#ifndef PRETTYREADER_WEBVIEWITEM_H
#define PRETTYREADER_WEBVIEWITEM_H

#include "layoutengine.h"
#include "webviewrenderer.h"

#include <QGraphicsItem>

class FontManager;

class WebViewItem : public QGraphicsItem
{
public:
    explicit WebViewItem(FontManager *fontManager);

    void setLayoutResult(Layout::ContinuousLayoutResult &&result);
    const Layout::ContinuousLayoutResult &layoutResult() const { return m_result; }

    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
               QWidget *widget) override;

    const QList<LinkHitRect> &linkHitRects() const { return m_renderer.linkHitRects(); }
    QString linkAt(const QPointF &pos) const;

private:
    int firstVisibleElement(qreal top) const;

    Layout::ContinuousLayoutResult m_result;
    WebViewRenderer m_renderer;
};

#endif // PRETTYREADER_WEBVIEWITEM_H
```

**Step 2: Create `webviewitem.cpp`**

```cpp
/*
 * webviewitem.cpp — QGraphicsItem for continuous web view rendering
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

#include "webviewitem.h"

#include <QPainter>
#include <QStyleOptionGraphicsItem>

WebViewItem::WebViewItem(FontManager *fontManager)
    : m_renderer(fontManager)
{
}

void WebViewItem::setLayoutResult(Layout::ContinuousLayoutResult &&result)
{
    prepareGeometryChange();
    m_result = std::move(result);
    m_renderer.clearLinkHitRects();
    update();
}

QRectF WebViewItem::boundingRect() const
{
    return QRectF(0, 0, m_result.contentWidth, m_result.totalHeight);
}

// Binary search for the first element whose bottom edge is >= top
int WebViewItem::firstVisibleElement(qreal top) const
{
    int lo = 0;
    int hi = m_result.elements.size();
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        qreal elemBottom = 0;
        std::visit([&](const auto &e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, Layout::BlockBox>)
                elemBottom = e.y + e.height;
            else if constexpr (std::is_same_v<T, Layout::TableBox>)
                elemBottom = e.y + e.height;
            else if constexpr (std::is_same_v<T, Layout::FootnoteSectionBox>)
                elemBottom = e.y + e.height;
        }, m_result.elements[mid]);

        if (elemBottom < top)
            lo = mid + 1;
        else
            hi = mid;
    }
    return lo;
}

void WebViewItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
                         QWidget * /*widget*/)
{
    QRectF exposed = option->exposedRect;
    m_renderer.clearLinkHitRects();

    int startIdx = firstVisibleElement(exposed.top());

    for (int i = startIdx; i < m_result.elements.size(); ++i) {
        const auto &element = m_result.elements[i];

        qreal elemY = 0;
        std::visit([&](const auto &e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, Layout::BlockBox>)
                elemY = e.y;
            else if constexpr (std::is_same_v<T, Layout::TableBox>)
                elemY = e.y;
            else if constexpr (std::is_same_v<T, Layout::FootnoteSectionBox>)
                elemY = e.y;
        }, element);

        // Stop if we've passed the visible area
        if (elemY > exposed.bottom())
            break;

        std::visit([&](const auto &e) {
            using T = std::decay_t<decltype(e)>;
            if constexpr (std::is_same_v<T, Layout::BlockBox>)
                m_renderer.renderBlockBox(painter, e);
            else if constexpr (std::is_same_v<T, Layout::TableBox>)
                m_renderer.renderTableBox(painter, e);
            else if constexpr (std::is_same_v<T, Layout::FootnoteSectionBox>)
                m_renderer.renderFootnoteSectionBox(painter, e);
        }, element);
    }
}

QString WebViewItem::linkAt(const QPointF &pos) const
{
    for (const auto &link : m_renderer.linkHitRects()) {
        if (link.rect.contains(pos))
            return link.href;
    }
    return {};
}
```

**Step 3: Add files to `src/CMakeLists.txt`**

Insert after the WebViewRenderer lines added in Task 2:

```cmake
    canvas/webviewitem.cpp
    canvas/webviewitem.h
```

**Step 4: Build and verify**

Run: `cmake --build build --target PrettyReaderCore -j$(nproc)`
Expected: Compiles clean.

**Step 5: Commit**

```
feat(canvas): add WebViewItem for continuous web view display

QGraphicsItem that hosts a ContinuousLayoutResult and paints it
using WebViewRenderer. Uses binary search to only paint elements
overlapping the exposed rect for performance.
```

---

### Task 4: Add `RenderMode` setting to KConfig

**Files:**
- Modify: `src/app/prettyreader.kcfg:49-64` (add entry to Rendering group)

**Step 1: Add `UseWebView` entry**

Insert after the `UsePdfRenderer` entry (after line 63, before the `</group>` tag):

```xml
    <entry name="UseWebView" type="Bool">
      <label>Use continuous web view instead of paginated print view.</label>
      <default>false</default>
    </entry>
```

**Step 2: Build to regenerate settings class**

Run: `cmake --build build --target PrettyReaderCore -j$(nproc)`
Expected: `PrettyReaderSettings::self()->useWebView()` and `setUseWebView()` now available.

**Step 3: Commit**

```
feat(settings): add UseWebView setting for render mode persistence
```

---

### Task 5: Integrate web view into DocumentView

**Files:**
- Modify: `src/canvas/documentview.h`
- Modify: `src/canvas/documentview.cpp`

**Step 1: Add includes, enum, and members to `documentview.h`**

Add forward declaration near the top (with other forward declarations):

```cpp
class WebViewItem;
```

Add include:

```cpp
#include "layoutengine.h"
```

Add `RenderMode` enum (near the existing `ViewMode` enum, around line 106):

```cpp
    enum RenderMode { PrintMode, WebMode };
```

Add new public methods (in the public section):

```cpp
    void setRenderMode(RenderMode mode);
    RenderMode renderMode() const { return m_renderMode; }
    void setWebContent(Layout::ContinuousLayoutResult &&result);
```

Add new signal:

```cpp
    void renderModeChanged(RenderMode mode);
    void webRelayoutRequested();
```

Add new private members (in the private section):

```cpp
    RenderMode m_renderMode = PrintMode;
    WebViewItem *m_webViewItem = nullptr;
    QTimer m_relayoutTimer;
    qreal m_lastWebWidth = 0;
```

**Step 2: Implement in `documentview.cpp`**

Add includes at the top:

```cpp
#include "webviewitem.h"
#include <QTimer>
```

In the constructor, set up the debounce timer:

```cpp
    m_relayoutTimer.setSingleShot(true);
    m_relayoutTimer.setInterval(200);
    connect(&m_relayoutTimer, &QTimer::timeout, this, [this]() {
        Q_EMIT webRelayoutRequested();
    });
```

Add `setRenderMode()`:

```cpp
void DocumentView::setRenderMode(RenderMode mode)
{
    if (m_renderMode == mode)
        return;
    m_renderMode = mode;
    Q_EMIT renderModeChanged(mode);
}
```

Add `setWebContent()`:

```cpp
void DocumentView::setWebContent(Layout::ContinuousLayoutResult &&result)
{
    m_scene->clear();
    m_pageItems.clear();
    m_pdfPageItems.clear();
    m_webViewItem = nullptr;

    FontManager *fm = nullptr;
    // FontManager is passed via the result's context — we need a reference.
    // WebViewItem takes FontManager* in its constructor.
    // We'll pass it from MainWindow through a setter.

    // For now, create the item and add to scene
    // (FontManager will be set by MainWindow before calling this)
    if (!m_webViewItem) {
        m_webViewItem = new WebViewItem(m_webFontManager);
        m_scene->addItem(m_webViewItem);
    }

    m_webViewItem->setLayoutResult(std::move(result));
    m_webViewItem->setPos(kSceneMargin, kSceneMargin);

    qreal sceneW = m_webViewItem->boundingRect().width() + kSceneMargin * 2;
    qreal sceneH = m_webViewItem->boundingRect().height() + kSceneMargin * 2;
    m_scene->setSceneRect(0, 0, sceneW, sceneH);

    m_lastWebWidth = m_webViewItem->boundingRect().width();

    setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
}
```

Actually, let me revise this — instead of storing FontManager in DocumentView, the better approach is to pass it through `setWebContent()`. Let me simplify. The `WebViewItem` needs a `FontManager*` and it only uses it for `QRawFont` creation. The simplest approach: add a `setFontManager()` to DocumentView for web mode.

**Revised Step 1 members:**

```cpp
    FontManager *m_webFontManager = nullptr;
```

And add a public setter:

```cpp
    void setWebFontManager(FontManager *fm) { m_webFontManager = fm; }
```

**Step 3: Modify `resizeEvent()` for debounced relayout**

Replace the existing `resizeEvent()` (line 716) with:

```cpp
void DocumentView::resizeEvent(QResizeEvent *event)
{
    QGraphicsView::resizeEvent(event);
    if (m_renderMode == WebMode) {
        m_relayoutTimer.start(); // restart 200ms debounce
    }
}
```

**Step 4: Update heading tracking for web mode**

In `updateCurrentPage()` (line 1573), add a web mode branch that
uses `m_webViewItem`'s absolute heading positions instead of
page-based ones. The heading positions from the source map entries
can be used directly since they're absolute y-coordinates.

**Step 5: Build and verify**

Run: `cmake --build build --target PrettyReaderCore -j$(nproc)`
Expected: Compiles clean.

**Step 6: Commit**

```
feat(canvas): integrate web view mode into DocumentView

Adds RenderMode enum (PrintMode/WebMode), setWebContent() to display
a ContinuousLayoutResult, and debounced resize handling for relayout.
```

---

### Task 6: Integrate web view into MainWindow

**Files:**
- Modify: `src/app/mainwindow.h`
- Modify: `src/app/mainwindow.cpp`
- Modify: `src/app/prettyreaderui.rc`

**Step 1: Add members to `mainwindow.h`**

Add private member:

```cpp
    QAction *m_webViewAction = nullptr;
    QAction *m_printViewAction = nullptr;
    KActionMenu *m_pageArrangementMenu = nullptr;
```

**Step 2: Add render mode toggle actions in `setupActions()`**

Insert before the "View > Mode" section (before line 351). Create a
new `QActionGroup` for render mode:

```cpp
    // View > Render Mode (Print vs Web)
    auto *renderModeGroup = new QActionGroup(this);
    renderModeGroup->setExclusive(true);

    m_printViewAction = ac->addAction(QStringLiteral("view_print_mode"));
    m_printViewAction->setText(i18n("&Print View"));
    m_printViewAction->setIcon(QIcon::fromTheme(QStringLiteral("document-print-preview")));
    m_printViewAction->setCheckable(true);
    m_printViewAction->setChecked(!PrettyReaderSettings::self()->useWebView());
    m_printViewAction->setActionGroup(renderModeGroup);
    connect(m_printViewAction, &QAction::triggered, this, [this]() {
        PrettyReaderSettings::self()->setUseWebView(false);
        PrettyReaderSettings::self()->save();
        onRenderModeChanged();
    });

    m_webViewAction = ac->addAction(QStringLiteral("view_web_mode"));
    m_webViewAction->setText(i18n("&Web View"));
    m_webViewAction->setIcon(QIcon::fromTheme(QStringLiteral("text-html")));
    m_webViewAction->setCheckable(true);
    m_webViewAction->setChecked(PrettyReaderSettings::self()->useWebView());
    m_webViewAction->setActionGroup(renderModeGroup);
    connect(m_webViewAction, &QAction::triggered, this, [this]() {
        PrettyReaderSettings::self()->setUseWebView(true);
        PrettyReaderSettings::self()->save();
        onRenderModeChanged();
    });
```

Store the page arrangement menu (modify the existing code around line 417):

```cpp
    m_pageArrangementMenu = arrangementMenu;
```

**Step 3: Add `onRenderModeChanged()` to `mainwindow.h` and `.cpp`**

Declare in header (private slots):

```cpp
    void onRenderModeChanged();
```

Implement:

```cpp
void MainWindow::onRenderModeChanged()
{
    bool webMode = PrettyReaderSettings::self()->useWebView();

    // Enable/disable page arrangement
    if (m_pageArrangementMenu)
        m_pageArrangementMenu->setEnabled(!webMode);

    auto *view = currentDocumentView();
    if (view)
        view->setRenderMode(webMode ? DocumentView::WebMode : DocumentView::PrintMode);

    rebuildCurrentDocument();
}
```

**Step 4: Add web pipeline branch to `rebuildCurrentDocument()`**

Inside the `if (PrettyReaderSettings::self()->usePdfRenderer())` branch (line 1058),
add a check for web mode. After building the `contentDoc` and creating the layout engine
(around line 1078), branch:

```cpp
    if (PrettyReaderSettings::self()->useWebView()) {
        // Web view pipeline: layout → direct QPainter rendering
        qreal availWidth = view->viewport()->width() - 2 * DocumentView::kSceneMargin;
        qreal zoomFactor = view->currentZoom() / 100.0;
        if (zoomFactor > 0)
            availWidth /= zoomFactor;
        if (availWidth < 200)
            availWidth = 200; // minimum width

        Layout::ContinuousLayoutResult webResult =
            layoutEngine.layoutContinuous(contentDoc, availWidth);

        view->setWebFontManager(m_fontManager);
        view->setWebContent(std::move(webResult));
        view->setRenderMode(DocumentView::WebMode);
        // ... heading positions, TOC, etc. adapted for web mode
    } else {
        // Existing PDF pipeline (lines 1080-1124)
        ...
    }
```

The heading positions for web mode use the source map's absolute y-coordinates
(since `pageNumber` is always 0 and `rect.top()` is the absolute y):

```cpp
    // Build heading positions for web mode
    QList<HeadingPosition> headingPositions;
    for (const auto &block : contentDoc.blocks) {
        const auto *heading = std::get_if<Content::Heading>(&block);
        if (!heading || heading->level < 1 || heading->level > 6)
            continue;
        HeadingPosition hp;
        hp.page = 0;
        if (heading->source.startLine > 0) {
            for (const auto &entry : webResult.sourceMap) {
                if (entry.startLine == heading->source.startLine
                    && entry.endLine == heading->source.endLine) {
                    hp.yOffset = entry.rect.top();
                    break;
                }
            }
        }
        headingPositions.append(hp);
    }
    view->setHeadingPositions(headingPositions);
```

**Step 5: Wire `webRelayoutRequested` signal**

In `rebuildCurrentDocument()`, connect the relayout signal:

```cpp
    connect(view, &DocumentView::webRelayoutRequested,
            this, &MainWindow::rebuildCurrentDocument,
            Qt::UniqueConnection);
```

**Step 6: Update `prettyreaderui.rc`**

Add the render mode actions to the View menu (after line 34, before the Page Arrangement):

```xml
      <Action name="view_print_mode"/>
      <Action name="view_web_mode"/>
      <Separator/>
```

Add to the toolbar (after `view_zoom_fit_width`, before `view_page_arrangement`):

```xml
    <Action name="view_print_mode"/>
    <Action name="view_web_mode"/>
```

**Note:** Bump the `version` attribute in `<gui>` from `8` to `9` so KDE picks up the
new toolbar layout.

**Step 7: Build and test**

Run: `cmake --build build -j$(nproc) && ./build/bin/prettyreader`
Expected: Print/Web toggle buttons appear in toolbar. Clicking "Web" triggers
a continuous layout rendered via QPainter. Clicking "Print" switches back to
the paginated PDF view.

**Step 8: Commit**

```
feat(app): wire web view mode into MainWindow with Print/Web toggle

Adds toolbar toggle between Print and Web view modes. Web mode
bypasses PDF generation, using layoutContinuous() + WebViewRenderer
for direct QPainter rendering. Page arrangement disabled in web mode.
Debounced resize triggers relayout.
```

---

### Task 7: Zoom support in web mode

**Files:**
- Modify: `src/canvas/documentview.cpp` (`setZoomPercent()` and `resizeEvent()`)

**Step 1: Modify `setZoomPercent()` for web mode**

In `setZoomPercent()` (line 532), add a web mode branch that applies the
`QGraphicsView::scale()` immediately and starts the debounce timer:

```cpp
    if (m_renderMode == WebMode) {
        m_currentZoom = percent;
        qreal factor = percent / 100.0;
        resetTransform();
        scale(factor, factor);
        m_relayoutTimer.start(); // debounced relayout at new effective width
        Q_EMIT zoomChanged(percent);
        return;
    }
```

**Step 2: Build and test**

Test: Open a document in web mode, zoom in/out. Text should scale immediately,
then reflow after 200ms to have correct line breaks at the new scale.

**Step 3: Commit**

```
feat(canvas): support zoom in web view mode

Zoom applies QGraphicsView::scale() immediately for visual feedback,
then triggers a debounced relayout at the new effective viewport width.
```

---

### Task 8: Scroll position preservation across relayout

**Files:**
- Modify: `src/canvas/documentview.cpp`

**Step 1: Save/restore heading anchor across web relayout**

Before the `webRelayoutRequested` signal triggers a rebuild, the current heading
index and its viewport position should be captured. After rebuild, scroll to
restore that heading at the same viewport offset.

In `setWebContent()`, after setting up the scene, restore the heading anchor:

```cpp
    // If we have a saved heading index, scroll to it
    if (m_currentHeading >= 0 && m_currentHeading < m_headingPositions.size()) {
        qreal headingY = m_headingPositions[m_currentHeading].yOffset;
        qreal sceneY = headingY + kSceneMargin;
        centerOn(0, sceneY);
    }
```

**Step 2: Build and test**

Test: Open a long document in web mode, scroll to a heading, resize the window.
After relayout, the same heading should still be visible near the same position.

**Step 3: Commit**

```
feat(canvas): preserve scroll position across web view relayout

Records the topmost visible heading before relayout and scrolls
back to it after. Prevents jarring position jumps during resize.
```

---

### Task 9: Link hover and click in web view

**Files:**
- Modify: `src/canvas/documentview.cpp` (mouse event handlers)

**Step 1: Add web view link handling to existing mouse handlers**

DocumentView already has `mouseMoveEvent()` and `mousePressEvent()` for link
handling in PDF mode (uses Poppler link annotations). Add a web mode branch
that queries `WebViewItem::linkAt()`:

In `mouseMoveEvent()`, add after existing link detection:

```cpp
    if (m_renderMode == WebMode && m_webViewItem) {
        QPointF scenePos = mapToScene(event->pos());
        QPointF itemPos = m_webViewItem->mapFromScene(scenePos);
        QString href = m_webViewItem->linkAt(itemPos);
        if (!href.isEmpty()) {
            viewport()->setCursor(Qt::PointingHandCursor);
            Q_EMIT statusHintChanged(href);
        } else {
            viewport()->setCursor(Qt::ArrowCursor);
            Q_EMIT statusHintChanged({});
        }
    }
```

In `mousePressEvent()`, add a similar branch that opens the link with
`QDesktopServices::openUrl()`.

**Step 2: Build and test**

Test: Open a markdown file with links in web mode. Hover should show cursor
change and status bar hint. Click should open the link.

**Step 3: Commit**

```
feat(canvas): add link hover and click support in web view mode
```

---

### Task 10: Final integration testing and polish

**Step 1: Test with various document types**

- Simple paragraphs with body text
- Headings at all 6 levels
- Code blocks (fenced and indented)
- Tables (narrow and wide)
- Images
- Blockquotes (nested)
- Lists (ordered, unordered, nested, with checkboxes)
- Footnotes (verify they appear at bottom)
- Horizontal rules
- Links (hover and click)
- Documents with Hershey fonts

**Step 2: Test view mode switching**

- Switch Print → Web → Print: verify no crashes, correct rendering
- Verify page arrangement menu disables in web mode
- Verify zoom works in both modes
- Verify TOC scroll-sync works in web mode

**Step 3: Test resize behavior**

- Drag window wider/narrower: verify debounced relayout
- Verify scroll position preserved after relayout
- Verify no excessive relayout during drag

**Step 4: Fix any issues found during testing**

Address rendering discrepancies, layout bugs, or integration issues.

**Step 5: Commit**

```
fix(canvas): polish web view rendering and integration

Address issues found during integration testing.
```
